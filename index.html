<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по Java (ООП)</title>
    <style>
        body { font-family: sans-serif; background-color: #f0f2f5; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 600px; width: 100%; }
        h2 { color: #333; margin-bottom: 20px; font-size: 1.2em; }
        .btn { display: block; width: 100%; padding: 12px; margin: 8px 0; border: 2px solid #e0e0e0; background: #fff; border-radius: 5px; cursor: pointer; text-align: left; font-size: 1em; transition: 0.2s; }
        .btn:hover { background-color: #f9f9f9; border-color: #ccc; }
        .correct { background-color: #d4edda !important; border-color: #c3e6cb !important; color: #155724; }
        .wrong { background-color: #f8d7da !important; border-color: #f5c6cb !important; color: #721c24; }
        .next-btn { display: none; margin-top: 20px; padding: 12px 24px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%; }
        .next-btn:hover { background-color: #0056b3; }
        .stats { margin-top: 15px; font-size: 0.9em; color: #666; text-align: right; }
    </style>
</head>
<body>

<div class="container">
    <div id="quiz-box">
        <h2 id="question-text">Загрузка...</h2>
        <div id="options-box"></div>
        <button id="next-btn" class="next-btn" onclick="nextQuestion()">Следующий вопрос</button>
        <div class="stats" id="stats"></div>
    </div>
</div>

<script>
    // Данные из твоего файла, начиная с "Переменная области памяти..."
    // Первый вариант в списке options всегда верный (согласно структуре твоего документа),
    // но при отображении мы их перемешаем.
    const questions = [
        {q: "Переменная области памяти может быть записана как", options: ["ссылка на объект", "ссылка на аргумент", "ссылка на класс", "ссылка на суперкласс", "ссылка на метод"]},
        {q: "Для создания объекта используется оператор", options: ["new", "Copy", "Paste", "Cut", "Old"]},
        {q: "Методы классов отличаются сигнатурой", options: ["типом результата, именем и (или) списком аргументов", "Типом полей, свойствами объекта", "Типом данных, атрибутами полей", "Синтаксисом, переменными", "Ключевыми полями"]},
        {q: "Члены класса считаются открытыми, если", options: ["ключевое слово не указано", "ключевое слово указано", "ключевое слово содержит информацию", "ключевое слово связано с внешним ключом", "ключевое слово вызывается"]},
        {q: "Определите хронологию вызова при создании объекта подкласса", options: ["сначала вызывается конструктор суперкласса, а затем непосредственно конструктор подкласса", "сначала вызывается мастер суперкласса, а затем непосредственно конструктор суперкласса", "сначала вызывается конструктор подкласса, а затем непосредственно мастер подкласса", "сначала вызывается метод суперкласса, а затем мастер подкласса", "сначала вызывается конструктор подкласса, а затем непосредственно конструктор суперкласса"]},
        {q: "Конструктором суперкласса выделяется в памяти место", options: ["для всех членов объекта", "Для всех членов групп", "Для всех членов класса", "Для всех членов суперкласса", "Для всех членов метода"]},
        {q: "Каким ключевым словом добавляется инструкция вызова конструктора суперкласса с указанием аргументов", options: ["super (аргументы)", "Max (аргументы)", "Min (аргументы)", "Count (аргументы)", "abstract(аргументы)"]},
        {q: "Определите синтаксис объявления конструктора подкласса", options: ["конструктор_подкласса (аргументы1) {super(аргументы2); // аргументы конструктора суперкласса// тело конструктора подкласса", "interface имя1 extends имя2 {// тело интерфейса}", "class имя [extends суперкласс] implements интерфейс1, интерфейс2 … {// тело класса}", "конструктор_суперкласса(аргументы1) {super(аргументы2); // аргументы конструктора суперкласса// тело конструктора", "extends имя1 interface имя2 {// тело интерфейса}"]},
        {q: "При использовании многоуровневого наследования подкласс становится", options: ["суперклассом для другого подкласса", "Классом для другого класса", "Методом для другого подкласса", "Объектом для другого класса", "Конструктором для другого суперкласса"]},
        {q: "Объектная переменная — это переменная, значением которой является", options: ["ссылка на объект соответствующего класса", "ссылка на объект подкласса", "ссылка на объект соответствующего метода", "ссылка на метод соответствующего класса", "метод, тело которого содержит сигнатуру"]},
        {q: "Отличие объектной переменной от переменной базового типа", options: ["в качестве типа переменной указывается имя класса", "в качестве типа переменной указывается имя суперкласса", "в качестве типа переменной указывается имя объекта", "в качестве типа переменной указывается имя метода", "в качестве типа переменной указывается имя конструктора"]},
        {q: "В качестве значения объектной переменной суперкласса присваивается", options: ["ссылкой на объект подкласса", "ссылкой на объект соответствующего класса", "ссылкой на объект соответствующего метода", "ссылкой на метод соответствующего класса", "метод, тело которого содержит сигнатуру"]},
        {q: "Под абстрактным методом подразумевают", options: ["метод, тело которого содержит сигнатуру (тип результата, имя и список аргументов)", "ссылка на аргумент", "ссылка на класс", "ссылка на суперкласс", "ссылка на метод"]},
        {q: "Перед абстрактным методом указывается идентификатор", options: ["abstract", "super", "Max", "Min", "Count"]},
        {q: "Класс, который содержит абстрактный метод, называется", options: ["абстрактным", "Простым", "Сложным", "Полезным", "составным"]},
        {q: "Использование абстрактных классов", options: ["при создании сложных иерархий классов", "при создании простых иерархий суперклассов", "при создании сложных сетевых классов", "при создании сложных реляционных классов", "при создании сложных классов и объектов"]},
        {q: "С помощью какого ключевого слова можно защитить метод от возможного переопределения в подклассе", options: ["final", "Copy", "Paste", "Cut", "Old"]},
        {q: "Третий способ использования ключевого слова final", options: ["запрет на изменение значения поля (определение константы)", "разрешение на изменение значения поля (определение константы)", "запрет на ввод значения поля (определение константы)", "разрешение на просмотр значения поля (определение константы)", "указывается имя суперкласса, на основе которого создается подкласс"]},
        {q: "При создании подкласса после его имени через ключевое слово extends", options: ["указывается имя суперкласса, на основе которого создается подкласс", "указывается имя класса, на основе которого создается подкласс", "указывается имя объекта, на основе которого создается подкласс", "указывается имя метода, на основе которого создается подкласс", "указывается имя подкласса, на основе которого создается суперкласс"]},
        {q: "Все классы проекта разбиваются по группам, которые называются", options: ["пакетами", "ядрами", "числами", "группами", "интерфейсами"]},
        {q: "Имя класса должно быть уникальным", options: ["в пределах своего пакета", "в пределах файла", "в пределах группы", "в пределах класса", "в пределах подкласса"]},
        {q: "Для определения пакета необходимо в файле с описанием класса, включаемого в пакет", options: ["первой командой указать инструкцию package и имя пакета", "первой командой указать инструкцию file и имя пакета", "первой командой указать инструкцию class и имя пакета", "первой командой указать инструкцию new и имя пакета", "первой командой указать инструкцию object и имя пакета"]},
        {q: "Пакет, кроме классов, может содержать", options: ["интерфейсы и подпакеты", "Функции и переменные", "Классы и объекты", "Классы и суперклассы", "Файлы и папки"]},
        {q: "Назовите правило, которое не относится к характеристикам с доступностью различных членов класса", options: ["Имя файла должно совпадать с именем открытого класса, если такой класс существует в файле", "Наличие идентификатора public у члена класса означает, что он доступен везде: как в классе, так и за его пределами и даже в классах других пакетов", "Наличие идентификатора private означает, что член доступен только в пределах класса, где он объявлен", "Если у члена нет идентификатора доступа, он доступен в пределах пакета", "Члены класса, объявленные с идентификатором protected, доступны в пакете и в подклассах вне пакета"]},
        {q: "Если в программе выполняется обращение к классам, размещенным во внешних пакетах, необходимо указывать", options: ["полное имя класса: через точку перечисляется вся иерархия пакетов, где размещен нужный класс", "полное имя объекта: через точку перечисляется вся иерархия объектов, где размещен нужный объект", "полное имя суперкласса: через точку перечисляется вся иерархия пакетов, где размещен нужный суперкласс", "полное имя пакета: через точку перечисляется вся иерархия пакетов, где размещен нужный суперкласс", "полное имя файла: через точку перечисляется вся иерархия файлов, где размещен нужный файл"]},
        {q: "Ключевое слово import используется", options: ["при ссылке на классы внешних пакетов", "при ссылке на классы внутренних пакетов", "при ссылке на объекты внешних классов", "при ссылке на интерфейсы", "при ссылке на метод"]},
        {q: "Для импорта класса после ключевого слова import указывают", options: ["полное имя класса (с учетом иерархии пакетов)", "полное имя суперкласса (с учетом иерархии пакетов)", "полное имя файла (с учетом иерархии пакетов)", "полное имя пакета (с учетом иерархии пакетов)", "полное имя метода (с учетом иерархии пакетов)"]},
        {q: "Для импорта всего пакета после имени пакета ставят", options: ["*", "@", "&", "~", "%"]},
        {q: "Назовите ограничение, не относящееся к импорту пакетов", options: ["через точку перечисляется вся иерархия файлов, где размещен нужный файл", "Импортировать можно только открытые классы", "Пакет java.lang (базовая библиотека) можно не импортировать — он и так доступен", "Имя файла должно совпадать с именем открытого класса, если такой класс существует в файле", "Если в пакете несколько открытых классов, они должны размещаться в разных файлах"]},
        {q: "Отличие интерфейса от класса", options: ["содержит только сигнатуры методов без описания, а также поля-константы", "разрешение на изменение значения поля (определение константы)", "запрет на ввод значения поля (определение константы)", "разрешение на просмотр значения поля (определение константы)", "указывается имя суперкласса, на основе которого создается подкласс"]},
        {q: "Описание интерфейса задается", options: ["ключевым словом interface", "ключевым словом package", "ключевым словом paskage", "ключевым словом short", "ключевым словом boolean"]},
        {q: "Описываемые в интерфейсе поля по умолчанию считаются", options: ["неизменяемыми и статическими", "Изменяемыми и динамическими", "простыми и сложными", "ключевыми и простыми", "внутренними и внешними"]},
        {q: "Класс, который реализует интерфейс, должен содержать", options: ["описание всех методов интерфейса", "описание всех классов интерфейса", "описание всех функций интерфейса", "описание всех переменных интерфейса", "описание всех аргументов интерфейса"]},
        {q: "Для реализации интерфейса в классе в сигнатуре заголовка класса указывается инструкция", options: ["implements()", "Exception()", "Throw()", "Package()", "Public()"]},
        {q: "Синтаксис объявления класса, который наследует суперкласс и реализует несколько интерфейсов", options: ["class имя [extends суперкласс] implements интерфейс1,интерфейс2 …{// тело класса}", "конструктор_подкласса(аргументы1){super(аргументы2); // аргументы конструктора суперкласса// тело конструктора подкласса", "interface имя1 extends имя2 {// тело интерфейса}", "конструктор_суперкласса(аргументы1){super(аргументы2); // аргументы конструктора суперкласса// тело конструктора", "extends имя1 interface имя2 {// тело интерфейса}"]},
        {q: "Когда один интерфейс может наследовать другой интерфейс – это", options: ["расширение интерфейса", "Открытие интерфейса", "Закрытие интерфейса", "Редактирование интерфейса", "передача интерфейса"]},
        {q: "При расширении интерфейсов указывается ключевое слово", options: ["extends", "object", "model", "private", "protect"]},
        {q: "Синтаксис реализации расширения интерфейса", options: ["interface имя1 extends имя2 {// тело интерфейса}", "class имя [extends суперкласс] implements интерфейс1,интерфейс2 …{// тело класса}", "конструктор_подкласса(аргументы1) {super(аргументы2); // аргументы конструктора суперкласса// тело конструктора подкласса", "конструктор_суперкласса(аргументы1) {super(аргументы2); // аргументы конструктора суперкласса// тело конструктора", "extends имя1 interface имя2 {// тело интерфейса}"]},
        {q: "Для работы с текстом служат два встроенных Java- класса:", options: ["String и StringBuffer", "Pause и Break", "Thred и Throw", "Call и Saw", "Top и Bottom"]},
        {q: "Принципиальное различие объекта класса String от объекта класса StringBuffer", options: ["объекты класса String изменять нельзя", "объекты класса String изменять можно", "объекты класса StringBuffer изменять нельзя", "объекты класса StringBuffer создаются на основе символьного массива", "объекты класса String выполняются непосредственно с аргументом"]},
        {q: "Назовите конструктор, не относящийся к классу String", options: ["Конструктор, принимающий в качестве типа переменной указывается имя суперкласса", "Конструктор создания пустой строки", "Конструктор создания текстовой строки на основе символьного массива", "Конструктор копирования объекта", "Конструктор, принимающий в качестве аргумента массив типа byte с кодами символов"]},
        {q: "Операнды при сложении текстовых значений могут быть", options: ["текст или число и объект класса, определенного пользователем", "субъект и объект класса, определенного пользователем", "аргумент класса, определенного системой", "метод класса, определенного пользователем", "функции класса, определенного системой"]},
        {q: "Метод toString() определен в классе", options: ["Object", "continue()", "Plus()", "Polynom(-)", "Double()"]},
        {q: "Назовите правило, не относящееся к представлению комплексного числа", options: ["текстовое представление действительной части комплексного числа", "Если действительная часть равна нулю, а мнимая отлична от нуля, то действительная часть не отображается", "Если и мнимая, и действительная части числа равны нулю, отображается действительная (нулевая) часть", "Если действительная часть отлична от нуля, а мнимая равна нулю, мнимая часть не отображается", "Если действительная часть не отображается, то не отображается и знак плюс перед мнимой частью"]},
        {q: "Переменная result представляется как объединение трех текстовых строк:", options: ["RePart, ImPart и sign", "equals() и equalsIgnoreCase()", "indexOf() и lastindexOf()", "insert() и lastindexOf()", "capacity() и ensureCapacity()"]},
        {q: "RePart", options: ["текстовое представление действительной части комплексного числа", "текстовое представление мнимой части комплексного числа с учетом мнимой единицы i", "знак между действительной и мнимой частями комплексного числа", "строки состоят из одинаковых символов, размещенных на одинаковых позициях в строке", "искомый символ (значение типа char) или подстрока (объект класса String)"]},
        {q: "ImPart –", options: ["текстовое представление мнимой части комплексного числа с учетом мнимой единицы i", "текстовое представление действительной части комплексного числа", "знак между действительной и мнимой частями комплексного числа", "строки состоят из одинаковых символов, размещенных на одинаковых позициях в строке", "искомый символ (значение типа char) или подстрока (объект класса String)"]},
        {q: "Sign", options: ["знак между действительной и мнимой частями комплексного числа", "текстовое представление действительной части комплексного числа", "текстовое представление мнимой части комплексного числа с учетом мнимой единицы i", "строки состоят из одинаковых символов, размещенных на одинаковых позициях в строке", "искомый символ (значение типа char) или подстрока (объект класса String)"]},
        {q: "Сравнение разных текстовых строк на предмет совпадения", options: ["equals() и equalsIgnoreCase()", "RePart, ImPart и sign", "IndexOf() и lastindexOf()", "insert() и lastindexOf()", "capacity() и ensureCapacity()"]},
        {q: "Метод equals() возвращает в качестве значения true, если", options: ["строки состоят из одинаковых символов, размещенных на одинаковых позициях в строке", "знак между действительной и мнимой частями комплексного числа", "текстовое представление действительной части комплексного числа", "текстовое представление мнимой части комплексного числа с учетом мнимой единицы i", "искомый символ (значение типа char) или подстрока (объект класса String)"]},
        {q: "Какие используются методы поиска подстроки в строке", options: ["методы indexOf() и lastindexOf()", "RePart , ImPart и sign", "indexOf() и lastindexOf()", "insert() и lastindexOf()", "capacity() и ensureCapacity()"]},
        {q: "Назовите первый аргумент методов indexOf() и lastindexOf()", options: ["искомый символ (значение типа char) или подстрока (объект класса String)", "строки состоят из одинаковых символов, размещенных на одинаковых позициях в строке", "знак между действительной и мнимой частями комплексного числа", "текстовое представление действительной части комплексного числа", "текстовое представление мнимой части комплексного числа с учетом мнимой единицы i"]},
        {q: "Назовите второй аргумент методов indexOf() и lastindexOf()", options: ["начальная точка поиска (индекс символа в строке, с которого начинается поиск)", "строки состоят из одинаковых символов, размещенных на одинаковых позициях в строке", "знак между действительной и мнимой частями комплексного числа", "текстовое представление действительной части комплексного числа", "текстовое представление мнимой части комплексного числа с учетом мнимой единицы i"]},
        {q: "Для метода indexOf() поиск выполняется", options: ["от точки поиска до конца строки", "от точки поиска до начала строки", "от точки объекта класса StringBuffer", "от точки, которые передаются программе при ее выполнении", "от точки после имени запускаемого на выполнение файла"]},
        {q: "Для метода lastindexOf() выполняется поиск", options: ["от точки поиска до начала строки", "объекты класса StringBuffer можно изменять", "параметры, которые передаются программе при ее выполнении", "пробел после имени запускаемого на выполнение файла", "в текстовый формат и передаются в виде текстового массива"]},
        {q: "Текстовый объект, который получается из строки вызова удалением начальных и конечных пробелов", options: ["trim()", "toLowerCase()", "toUpperCase()", "length()", "capacity()"]},
        {q: "Назовите метод, при котором ... возвращается текстовая строка ... в нижний регистр", options: ["toLowerCase()", "trim()", "toUpperCase()", "length()", "capacity()"]},
        {q: "Назовите метод, при котором ... возвращается текстовая строка ... в верхний регистр", options: ["toUpperCase()", "toLowerCase()", "trim()", "length()", "capacity()"]},
        {q: "Отличие объекта StringBuffer от объекта класса String", options: ["объекты класса StringBuffer можно изменять", "объекты класса String можно изменять", "объекты класса StringBuffer нельзя изменять", "объекты класса Buffer можно изменять", "объекты класса Buffer нельзя изменять"]},
        {q: "Метод возвращает текущую длину текстовой строки", options: ["length()", "ensureCapacity()", "setLength()", "capacity()", "charAt()"]},
        {q: "Метод возвращает выделенный для данной текстовой переменной объем памяти", options: ["capacity()", "length()", "ensureCapacity()", "setLength()", "charAt()"]},
        {q: "Метод выделения памяти для уже созданного объекта. Размер выделяемой памяти указывается аргументом метода", options: ["ensureCapacity()", "capacity()", "length()", "setLength()", "charAt()"]},
        {q: "Метод устанавливает длину текстовой строки (аргумент метода)", options: ["setLength()", "ensureCapacity()", "capacity()", "length()", "charAt()"]},
        {q: "Метод возвращает символ в строке с указанным индексом (аргумент метода)", options: ["charAt()", "setLength()", "ensureCapacity()", "capacity()", "length()"]},
        {q: "Метод, при котором в конец строки вызова добавляется текст, указанный аргументом метода", options: ["append()", "setLength()", "ensureCapacity()", "capacity()", "length()"]},
        {q: "Метод, при котором в строку вызова выполняется вставка текста... Первым аргументом метода указывается индекс...", options: ["insert()", "setLength()", "ensureCapacity()", "capacity()", "length()"]},
        {q: "Метод, который меняет порядок следования символов в строке вызова. Аргументов у метода нет", options: ["reverse()", "setLength()", "ensureCapacity()", "capacity()", "length()"]},
        {q: "Аргументы командной строки — это", options: ["параметры, которые передаются программе при ее выполнении", "пробел после имени запускаемого на выполнение файла", "в текстовый формат и передаются в виде текстового массива", "метод, который меняет порядок следования символов в строке вызова", "метод, при котором в строку вызова выполняется вставка текста, указанного вторым аргументом метода"]},
        {q: "При запуске консольных программ аргументы командной строки указываются через", options: ["пробел после имени запускаемого на выполнение файла", "параметры, которые передаются программе при ее выполнении", "в текстовый формат и передаются в виде текстового массива", "метод, который меняет порядок следования символов в строке вызова", "метод, при котором в строку вызова выполняется вставка текста, указанного вторым аргументом метода"]},
        {q: "В Java аргументы командной строки автоматически преобразуются", options: ["в текстовый формат и передаются в виде текстового массива", "в параметры, которые передаются программе при ее выполнении", "в текстовый формат и передаются в виде символьного массива", "в метод, который меняет порядок следования символов в строке вызова", "в метод, при котором в строку вызова выполняется вставка текста, указанного вторым аргументом метода"]}
    ];

    let currentQ = 0;

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function showQuestion() {
        if (currentQ >= questions.length) {
            document.getElementById('quiz-box').innerHTML = "<h2>Тест окончен! Молодец!</h2><button class='next-btn' style='display:block' onclick='location.reload()'>Начать заново</button>";
            return;
        }

        const qData = questions[currentQ];
        document.getElementById('question-text').innerText = (currentQ + 1) + ". " + qData.q;
        
        const optsDiv = document.getElementById('options-box');
        optsDiv.innerHTML = "";
        
        // Создаем копию вариантов и запоминаем правильный (он всегда первый в исходных данных)
        let correctText = qData.options[0];
        let opts = [...qData.options];
        shuffle(opts);

        opts.forEach(optText => {
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.innerText = optText;
            btn.onclick = function() { checkAnswer(this, optText === correctText); };
            optsDiv.appendChild(btn);
        });

        document.getElementById('next-btn').style.display = "none";
        document.getElementById('stats').innerText = `Вопрос ${currentQ + 1} из ${questions.length}`;
    }

    function checkAnswer(btn, isCorrect) {
        // Блокируем все кнопки
        const buttons = document.querySelectorAll('.btn');
        buttons.forEach(b => b.disabled = true);

        if (isCorrect) {
            btn.classList.add('correct');
        } else {
            btn.classList.add('wrong');
            // Подсветить правильный ответ
            const originalQ = questions[currentQ];
            const correctText = originalQ.options[0];
            buttons.forEach(b => {
                if (b.innerText === correctText) b.classList.add('correct');
            });
        }
        document.getElementById('next-btn').style.display = "block";
    }

    function nextQuestion() {
        currentQ++;
        showQuestion();
    }

    // Запуск
    showQuestion();

</script>
</body>
</html>
